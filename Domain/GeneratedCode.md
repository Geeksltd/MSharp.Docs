# Generated Code
This lesson explains about the entity class code generated by M#. First, we will take a look at the generated code for an entire class, then a breakdown of the generated code to understand the purpose and usage of each method or property.

In our "HelloWorld" project we have two entities:

1.  "User" entity, an abstract class. 
2.  "Employee" entity, which inherits from "User" entity.

## Entities Developed and Customized in M#
The screenshots below show the M# entity structures of "User" and "Employee".

```C#
using MSharp;

namespace Domain
{
    public class User : EntityType
    {
        public User()
        {
            Abstract();

            String("Email", 100).Mandatory().Unique().Accepts(TextPattern.EmailAddress);
            String("Password", 100).Accepts(TextPattern.Password);
        }
    }
}
```
The code above demonstrates a "User" entity developed in M# which has the following configuration:

1. Is marked as an "Abstract" class.
2. Has two properties "Email" and "Password".
3. "Email" property is marked as "Unique" and has "Text Pattern" set as "Email Address".
4. Both properties are mandatory.

```C#
using MSharp;

namespace Domain
{
    public class Employee : SubType<User>
    {
        public Employee()
        {

            String("Name").Mandatory();

            ToStringExpression("Name");
        }
    }
}
```

The code above demonstrates an "Employee" entity developed in M# which has the following configuration:

1. Inherits "User" entity.
2. Has two properties "Email" and "Password" inherited from "User" entity.
3. All Properties are marked as mandatory.

## Code Generated by M#
The code below show the code generated by M# for the User and Employee entities.
> **Note:** M# generated "Partial" classes for each entity type. 
> **Note:** M# has a base class "GuidEntity", which is inherited by all the entities.

```C#
/// <summary>Represents an instance of User entity type.</summary>
[EscapeGCop("Auto generated code.")]
public abstract partial class User : GuidEntity
{
    /* -------------------------- Constructor -----------------------*/
        
    /// <summary>Initializes a new instance of the User class.</summary>
    protected User() => Deleting.Handle(Cascade_Deleting);
        
    /* -------------------------- Properties -------------------------*/
        
    /// <summary>Gets or sets the value of Email on this User instance.</summary>
    public string Email { get; set; }
        
    /// <summary>Gets or sets the value of Password on this User instance.</summary>
    public string Password { get; set; }
        
    /* -------------------------- Methods ----------------------------*/
    /// <summary>
    /// Find and returns an instance of User from the database by its Email.<para/>
    ///                               If no matching User is found, it returns Null.<para/>
    /// </summary>
    /// <param name="email">The Email of the requested User.</param>
    /// <returns>
    /// The User instance with the specified Email or null if there is no User with that Email in the database.<para/>
    /// </returns>
    public static Task<User> FindByEmail(string email)
    {
        return Database.FirstOrDefault<User>(u => u.Email == email);
    }
        
    /// <summary>Returns a textual representation of this User.</summary>
    public override string ToString() => Email;
        
    /// <summary>Returns a clone of this User.</summary>
    /// <returns>
    /// A new User object with the same ID of this instance and identical property values.<para/>
    ///  The difference is that this instance will be unlocked, and thus can be used for updating in database.<para/>
    /// </returns>
    public new User Clone() => (User)base.Clone();
        
    /// <summary>
    /// Validates the data for the properties of this User and throws a ValidationException if an error is detected.<para/>
    /// </summary>
    protected override async Task ValidateProperties()
    {
        var result = new List<string>();
            
        if (Email.IsEmpty())
            result.Add("Email cannot be empty.");
            
        if (Email?.Length > 100)
            result.Add("The provided Email is too long. A maximum of 100 characters is acceptable.");
            
        // Ensure Email matches Email address pattern:
            
        if (Email.HasValue() && !System.Text.RegularExpressions.Regex.IsMatch(Email, "\\s*\\w+([-+.'\\w])*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*\\s*"))
            result.Add("The provided Email is not a valid Email address.");
            
        // Ensure uniqueness of Email.
            
        if (await Database.Any<User>(u => u.Email == Email && u != this))
            result.Add("Email must be unique. There is an existing User record with the provided Email.");
            
        if (Password?.Length > 100)
            result.Add("The provided Password is too long. A maximum of 100 characters is acceptable.");
            
        if (result.Any())
            throw new ValidationException(result.ToLinesString());
    }
        
    /// <summary>Handles the Deleting event of this User.</summary>
    /// <param name="source">The source of the event.</param>
    /// <param name="e">The CancelEventArgs instance containing the event data.</param>
    async Task Cascade_Deleting()
    {
        // Cascade delete the dependant Password reset tickets:
        await Database.DeleteAll<PasswordResetTicket>(p => p.UserId == ID);
    }
}
```

The code above shows generated code for the User entity. The class has "Abstract" keyword and two simple properties as configured earlier in the lesson. If you remember previous M# Entity code, we marked "Email and Password" properties of User with some methods e.g. mandatory, unique, text pattern etc.

In order to implement those methods, M# implements some methods, which you can see above above and are discussed in detail later in this lesson.

```C#
/// <summary>Represents an instance of Employee entity type.</summary>
[EscapeGCop("Auto generated code.")]
public partial class Employee : User
{
    /* -------------------------- Properties -------------------------*/
        
    /// <summary>Gets or sets the value of Name on this Employee instance.</summary>
    public string Name { get; set; }
        
    /* -------------------------- Methods ----------------------------*/
        
    /// <summary>Returns a textual representation of this Employee.</summary>
    public override string ToString() => Name;
        
    /// <summary>Returns a clone of this Employee.</summary>
    /// <returns>
    /// A new Employee object with the same ID of this instance and identical property values.<para/>
    ///  The difference is that this instance will be unlocked, and thus can be used for updating in database.<para/>
    /// </returns>
    public new Employee Clone() => (Employee)base.Clone();
        
    /// <summary>
    /// Validates the data for the properties of this Employee and throws a ValidationException if an error is detected.<para/>
    /// </summary>
    protected override async Task ValidateProperties()
    {
        var result = new List<string>();
            
        try
        {
            await base.ValidateProperties();
        }
        catch (ValidationException ex)
        {
            result.Add(ex.Message);
        }
            
        if (Name.IsEmpty())
            result.Add("Name cannot be empty.");
            
        if (Name?.Length > 200)
            result.Add("The provided Name is too long. A maximum of 200 characters is acceptable.");
            
        if (result.Any())
            throw new ValidationException(result.ToLinesString());
    }
}
```

The code above shows generated code for the Employee entity class. The class is derived from User entity as you can see above and has only one "Department" property as configured earlier in the lesson. The Employee class also has implemented functions above, which are discussed separately later in this lesson.

> **Note:** "Email and Password" properties are inherited from "User" entity and are accessible by "Employee" entity.

### Generated Entity Code Details

#### FindByEmail()

```C#
/// <summary>
/// Find and returns an instance of User from the database by its Email.<para/>
///                               If no matching User is found, it returns Null.<para/>
/// </summary>
/// <param name="email">The Email of the requested User.</param>
/// <returns>
/// The User instance with the specified Email or null if there is no User with that Email in the database.<para/>
/// </returns>
public static Task<User> FindByEmail(string email)
{
    return Database.FirstOrDefault<User>(u => u.Email == email);
}
```

M# generates the method shown above for each property which is marked as "Unique". In our lesson above, we marked "Email" property of "User" entity as "Unique" so; M# generates this method with "Public Static" keywords to make it accessible anywhere in the project and is used to fetch a User record from the database by email address.

#### ToString()

```C#
/// <summary>Returns a textual representation of this User.</summary>
public override string ToString() => Email;
```

This is a very important method. M# returns a property in this method, which is either set as unique, default, or picks the first string type property. This property is used for "String / Textual" representation of the entity instance and is used in various procedures e.g. comparing instances, displaying instances on UI etc. The picture above shows the "ToString" method of the User entity, which returns "Email" property, because of the "Unique" attribute defined in the beginning of our lesson.

```C#
/// <summary>Returns a textual representation of this Employee.</summary>
public override string ToString() => Name;
```

The code above demonstrates the "ToString" method of the Employee entity, which returns "Name" property Although Employee inherits the User entity it doesn’t return "Email" because we marked "Name" as "Default Property" in our lesson and M# "Overrides" the inherited method.

#### Clone()

M# calls this method whenever an instance is updated, it is also a very important method used by other M# generated functionality.

```C#
/// <summary>Returns a clone of this User.</summary>
/// <returns>
/// A new User object with the same ID of this instance and identical property values.<para/>
///  The difference is that this instance will be unlocked, and thus can be used for updating in database.<para/>
/// </returns>
public new User Clone() => (User)base.Clone();
```

```C#
/// <summary>Returns a clone of this Employee.</summary>
/// <returns>
/// A new Employee object with the same ID of this instance and identical property values.<para/>
///  The difference is that this instance will be unlocked, and thus can be used for updating in database.<para/>
/// </returns>
public new Employee Clone() => (Employee)base.Clone();
```

#### ValidateProperties()
This method is called every time an entity instance is inserted or updated in the database and implements all the validation related attributes of the defined properties and Entity uniqueness rules configured in M#.

```C#
/// <summary>
/// Validates the data for the properties of this User and throws a ValidationException if an error is detected.<para/>
/// </summary>
protected override async Task ValidateProperties()
{
    var result = new List<string>();
            
    if (Email.IsEmpty())
        result.Add("Email cannot be empty.");
            
    if (Email?.Length > 100)
        result.Add("The provided Email is too long. A maximum of 100 characters is acceptable.");
            
    // Ensure Email matches Email address pattern:
            
    if (Email.HasValue() && !System.Text.RegularExpressions.Regex.IsMatch(Email, "\\s*\\w+([-+.'\\w])*@\\w+([-.]\\w+)*\\.\\w+([-.]\\w+)*\\s*"))
        result.Add("The provided Email is not a valid Email address.");
            
    // Ensure uniqueness of Email.
            
    if (await Database.Any<User>(u => u.Email == Email && u != this))
        result.Add("Email must be unique. There is an existing User record with the provided Email.");
            
    if (Password?.Length > 100)
        result.Add("The provided Password is too long. A maximum of 100 characters is acceptable.");
            
    if (result.Any())
        throw new ValidationException(result.ToLinesString());
}
```

The above method implementation on User entity shows the validation attributes we configured in M#, shown in the beginning of this lesson e.g. Mandatory fields are checked by calling "IsEmpty (M# extension method)", Text pattern of "Email" is checked by validating against a regular expression, and uniqueness of "Email" is checked by calling "Database.Any (M# extension)" on User entity.

```C#
/// <summary>
/// Validates the data for the properties of this Employee and throws a ValidationException if an error is detected.<para/>
/// </summary>
protected override async Task ValidateProperties()
{
    var result = new List<string>();
            
    try
    {
        await base.ValidateProperties();
    }
    catch (ValidationException ex)
    {
        result.Add(ex.Message);
    }
            
    if (Name.IsEmpty())
        result.Add("Name cannot be empty.");
            
    if (Name?.Length > 200)
        result.Add("The provided Name is too long. A maximum of 200 characters is acceptable.");
            
    if (result.Any())
        throw new ValidationException(result.ToLinesString());
}
```

The above shown validation method is implemented on the Employee entity and calls base.ValidateProerties() method to validate all the inherited properties before validating any owned properties.